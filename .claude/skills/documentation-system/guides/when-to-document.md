# When to Create or Update Documentation

This guide helps you decide when to create CLAUDE.md files and supporting documentation.

## When to Create a CLAUDE.md File

### Always Create For:

**1. New Applications**
- Any new deployable server application
- Any new command-line tool
- Any new service or microservice

**Example:** Creating a new API server like `analytics_api`

**2. New Libraries/Packages**
- Shared libraries used by multiple projects
- Standalone packages
- Reusable components

**Example:** Creating a new shared library like `auth_lib`

**3. Major Functional Areas**
- Sectors within a project (like saga_api sectors)
- Modules with distinct responsibilities
- Logical groupings of related functionality

**Example:** Creating documentation for a new sector like `analytics/` in saga_api

**4. Technology Domains**
- When adding a new technology stack to the monorepo
- New language domains (e.g., Python, Go)

**Example:** Adding `/edu/python/CLAUDE.md` for new Python projects

### Consider Creating For:

**1. Complex Components**
- Components with > 5 files
- Components with unique patterns or conventions
- Components frequently modified by multiple developers

**Decision:** If it would take > 10 minutes to explain to a new developer, document it.

**2. Components with External Dependencies**
- Integration with third-party services
- Components requiring special setup or configuration
- Components with unusual build requirements

**Decision:** If setup is non-obvious, document it.

**3. Components with Security Implications**
- Authentication/authorization components
- Components handling PII or sensitive data
- Components with specific security requirements

**Decision:** Always document security-critical components.

### Don't Create For:

**1. Trivial Components**
- Single-file utilities
- Simple helper functions
- Components that are self-explanatory

**Example:** A 20-line date formatting utility

**2. Temporary/Experimental Code**
- Prototypes or spikes
- Code that may be deleted soon
- Experimental features not in production

**Example:** A proof-of-concept in a `experiments/` directory

**3. Auto-Generated Code**
- Code generated by tools
- Build artifacts
- Schema-generated types

**Example:** Prisma-generated client code

**4. When Parent Documentation Suffices**
- Very small components fully covered by parent
- Components with no unique patterns
- Components that are just implementations of parent's interface

**Example:** A simple GraphQL resolver that follows all parent patterns

## When to Update Existing CLAUDE.md

### Update When:

**1. Major Architectural Changes**
- Changing databases or storage systems
- Adopting new frameworks or libraries
- Restructuring the project

**Example:** Migrating from MongoDB to PostgreSQL

**2. Convention Changes**
- Adopting new code style or patterns
- Changing naming conventions
- New testing or deployment strategies

**Example:** Moving from Jest to Vitest

**3. New Critical Dependencies**
- Adding required external services
- New authentication mechanisms
- Integration with major third-party systems

**Example:** Adding Datadog APM integration

**4. Breaking Changes**
- API changes affecting consumers
- Configuration format changes
- Command-line interface changes

**Example:** Changing from REST to GraphQL API

**5. Discovered Critical Information**
- Security vulnerabilities or mitigations
- Performance gotchas or optimizations
- Undocumented assumptions or requirements

**Example:** Discovering that the service requires Node.js 18+ due to native modules

### Consider Updating When:

**1. Fixing Inaccuracies**
- Outdated information
- Incorrect examples
- Broken links

**Decision:** Fix errors immediately, but batch small corrections.

**2. Adding Clarity**
- Frequently asked questions
- Common confusion points
- New team members have questions

**Decision:** If multiple people ask the same question, document the answer.

**3. New Features (Minor)**
- Small feature additions
- New optional capabilities
- Non-breaking enhancements

**Decision:** Add to existing sections if it fits naturally, otherwise create supporting docs.

### Don't Update For:

**1. Implementation Details**
- Internal function changes (unless they expose new patterns)
- Bug fixes that don't change behavior
- Refactoring that maintains the same interface

**2. Temporary Changes**
- Feature flags or experiments
- Workarounds that will be removed
- Backward compatibility shims

**3. Cosmetic Changes**
- Code formatting changes
- Linter rule updates
- Comment additions

## When to Create Supporting Documentation (docs/)

### Create docs/ Files For:

**1. Detailed How-To Guides**
- Step-by-step procedures
- Complex workflows
- Troubleshooting guides

**File:** `docs/development.md`, `docs/troubleshooting.md`

**2. Comprehensive References**
- Complete API documentation
- Full command reference
- Configuration option catalogs

**File:** `docs/api.md`, `docs/configuration.md`

**3. In-Depth Explanations**
- Architecture deep-dives
- Design pattern explanations
- Performance optimization guides

**File:** `docs/architecture.md`, `docs/performance.md`

**4. When CLAUDE.md is Over Budget**
- Token count > 1000
- Too much detail in navigational file
- Multiple detailed topics

**Action:** Extract details to docs/, keep summary in CLAUDE.md

## When to Create Architecture Decision Records (ADRs)

### Create ADRs For:

**1. Architectural Choices**
- Database selection
- Framework adoption
- API design approach
- Build system selection

**Example:** `decisions/001-adopt-graphql.md`

**2. Convention Decisions**
- Code style choices (especially non-standard)
- Naming conventions
- Testing strategies
- Deployment approaches

**Example:** `decisions/002-use-snake-case.md`

**3. Technology Decisions**
- Language version choices
- Library/framework selections
- Tool adoption
- Platform choices

**Example:** `decisions/003-migrate-to-vitest.md`

**4. Trade-off Decisions**
- Performance vs maintainability
- Flexibility vs simplicity
- Any "we chose X over Y because" decisions

**Example:** `decisions/004-monorepo-vs-polyrepo.md`

### Don't Create ADRs For:

**1. Obvious Choices**
- Using TypeScript in a TypeScript project
- Standard practices for the ecosystem
- Vendor-recommended approaches

**2. Temporary Decisions**
- Short-term workarounds
- Decisions that will be revisited soon
- Experimental approaches

**3. Implementation Details**
- Specific function implementations
- File organization within established patterns
- Minor refactoring choices

## Decision Flowchart

```
Does this require developer context?
├─ No → Don't document
└─ Yes → Is it critical for using/understanding the component?
    ├─ No → Consider adding to existing docs/
    └─ Yes → Is parent documentation sufficient?
        ├─ Yes → Add to parent CLAUDE.md or docs/
        └─ No → Create new CLAUDE.md
            │
            └─ Is it a major decision?
                ├─ Yes → Also create ADR
                └─ No → Just CLAUDE.md

Is CLAUDE.md > 1000 tokens?
├─ No → Good to go
└─ Yes → Extract details to docs/
```

## Quick Decision Matrix

| Scenario | CLAUDE.md | docs/ | ADR |
|----------|-----------|-------|-----|
| New application | Yes | Yes | Maybe |
| New library | Yes | Yes | Maybe |
| New sector/module | Yes | Maybe | No |
| Small utility | No | No | No |
| Major arch change | Update Yes | Update Yes | Yes |
| Convention change | Update Yes | Update Yes | Yes |
| Bug fix | No | No | No |
| Detailed guide | No | Yes | No |
| Security update | Update Yes | Maybe | Maybe |
| Dependency change | Update Yes | Maybe | Maybe |

## Examples

### Good Reasons to Document

1. **New GraphQL Sector**
   - Create: `sectors/analytics/CLAUDE.md`
   - Include: Responsibilities, key queries/mutations, database collections
   - Why: Distinct functional area with its own patterns

2. **Adopting New Build System**
   - Update: Root `CLAUDE.md`, affected project CLAUDE.md files
   - Create: `decisions/NNN-adopt-nx.md`
   - Create: Updated `docs/development.md` with new build commands
   - Why: Major change affecting all developers

3. **Complex Authentication Flow**
   - Update: `auth/CLAUDE.md` with overview
   - Create: `auth/docs/authentication-flow.md` with details
   - Why: Critical security component, but details too long for CLAUDE.md

### Poor Reasons to Document

1. **Renaming a Function**
   - Don't update CLAUDE.md
   - Why: Implementation detail, no API change

2. **Adding a Helper File**
   - Don't create new CLAUDE.md
   - Why: Trivial utility within existing component

3. **Temporary Workaround**
   - Don't create ADR
   - Why: Not a permanent decision

## Key Principles

1. **Document decisions, not implementations**
2. **Document "why", not "what"** (code shows "what")
3. **Document the unusual, not the obvious**
4. **Keep CLAUDE.md navigational, not encyclopedic**
5. **Document what future developers will need to know**

---

*When in doubt, ask: "Will the next developer thank me for this documentation?"*
